               ::::::::   ::::::::  :::::::::  ::::::::::
              :+:    :+: :+:    :+: :+:    :+: :+:
              +:+        +:+        +:+    +:+ +:+
              +#++:++#++ +#++:++#++ +#+    +:+ +#++:++#
                     +#+        +#+ +#+    +#+ +#+
              #+#    #+# #+#    #+# #+#    #+# #+#
               ########   ########  #########  ##########

                The Small Scalable Disassembler Engine
Copyright (C) 2015, Constantine Shablya. See Copyright Notice in LICENSE.txt
                   http://github.com/notnanocat/ssde



 1 Что такое SSDE?
 2 "Зачем нужен SSDE, если дизассемблерные движки подобные HDE, diStorm,
  BeaEngine и т.д. уже существуют?" или "Преимущества SSDE"
  2.1 Производительность и бенчмарки
 3 Как использовать SSDE?
  3.1 Разные архитектуры
  3.2 Ошибки в декодировании инструкций
  3.3 Многопоточность
 4 Добавление поддержки новой архитектуры
 5 Сообщение об ошибке



1 Что такое SSDE?

  SSDE это маленький, масштабируемый дизассемблерный движок, предназначение
  которого заключается в анализе машинного кода и получения информации
  о инструкциях (их длина, опкод, правильность и т.д.).

  SSDE довольно функционален, например: на нем можно построить полноценный
  дизассемблер, который мог бы выводить ассемблерный текст программы,
  полученный из машинного кода посредством SSDE. Масштабируемость SSDE
  позволяет проводить анализ, предположим, нескольких ветвлений кода
  одновременно при помощи многопоточности.

2. "Зачем нужен SSDE, если дизассемблерные движки подобные
  HDE, diStorm, BeaEngine и т.д. уже существуют?" или "преимущества SSDE"

  Мотивацией для написания SSDE мне послужило то, что существующие движки
  либо слишком большие и/или были не свободными, либо они были слишком
  старыми. Кроме того, планируется поддержка других архитектур процессоров
  (в ближайшее время: x86 64, ARM32). Также хотел бы добавить, что SSDE
  лицензируется под MIT лицензией, что дает Вам право использовать его в
  своих приватных и/или коммерческих проектах без каких-либо ограничений
  и обязательств. Модули SSDE пишутся с расчетом на то, что они будут
  работать независимо от архитектуры и порядка байт процессора, ОС и т.д.
  Весь код SSDE написан на C++ с соблюдением стандарта C++11, весь public
  API документирован (смотри "ssde.hpp"), а реализация довольно чиста
  и сопровождаема.

  Главными преимуществами SSDE над другими движками являются:

    - модульность (используй только то, что нужно)
    - высокая производительность при анализе длинных последовательностей
        кода
    - небольшой размер
    - независим от архитектуры и порядка байт процессора, ОС
    - свободен в использовании


  ssde_x86 поддерживает новые и не очень расширения
        AES, SHA, VMX
        MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2, FMA3
        прочие мелкие расширения (CPUID, ADX, RDSEED, RDRAND и т.д.)

  ssde_x64 также поддерживает расширения, описаные выше. Кроме того,
        присутствует поддержка REX префикса, расширения Mod R/M с
        помощью REX, расширение imm с помощью REX.W и т.д.

2.1 Бенчмарки

  В настоящее время надлежащих бенчмарков проведено не было, однако, я
  провел микро бенчмарк ssde_x86 для сравнения производительности с HDE
  и выявления случаев, которые замедляют декодирование инструкций.

  cl 19.00.22816 (Visual C++ 2015) /O2
  win8.1 x64
  core i3 2350m @ 2.3 ГГц

  Анализ последовательности из 17 инструкций, 1M итераций

    SSDE : 4.942 с, 0.000029 с/инструкция
    HDE  : 5.542 с, 0.000032 с/инструкция

  Известны 2 случая, в которых SSDE проигрывает HDE в производительности:

    - частая реинициализация объекта дизассемблера
    - анализ инструкций, которые требуют чтения сдвигов,
        констант, относительных адресов и т.д.

  В последующих случаях бенчмарки будут проводиться на различных
  архитектурах (кроме x86, предположительно ARM LE и MIPS BE) под
  управлением ОС GNU/Linux.

3 Как использовать SSDE?

  SSDE написан на C++ с соблюдением стандарта C++11. Для подключения SSDE в
  проект требуется компилятор с поддержкой C++11.

  Каждый модуль имеет хотя бы два конструктора. Основной конструктор и
  конструктор копирования. Основной конструктор принимает

    1: контейнер std::string с бинарными данными.

  Коструктор копирования может быть использован для распараллеливания
  анализа, например: при анализе ветвлений. Конструктор копирования
  копирует ДАННЫЕ и УКАЗАТЕЛЬ ИНСТРУКЦИЙ (IP), но НЕ копирует информацию
  о инструкции.

3.1 Различные архитектуры

  Модульная структура позволяет подключить только те модули, которые нужны
  в проекте. Ключевым файлом является "ssde.hpp". "*.cpp" и прочие "*.hpp"
  файлы опциональны и могут быть опущены. Например: если Вы желаете
  использовать только SSDE для X86, то файлами, которые требуется подключить
  в проект, будут являться только "ssde.hpp", "ssde_x86.hpp" и "ssde_x86.cpp".

3.2 Ошибки при декодировании инструкций

  При декодировании инструкций могут возникнуть ошибки. Они возникают из-за
  неверно сформировавшихся инструкций в машинном коде. В большинстве
  случаев критических ошибок НЕ возникает и декодирование инструкций
  происходит правильно даже в случае возникновения ошибки. Однако, есть
  две исключительных ошибки, при возникновении которых правильное
  декодирование инструкций невозможно гарантировать. Ими являются:
  error_opcode и error_length. error_opcode возникает в случае, если
  декодер попытался декодировать какой-либо неизвестный ему опкод, а
  error_length - в случае, если длина инструкции превышает допустимую
  длинну инструкции.

  При возникновении какой-либо ошибки поле "error" будет установлено в "true",
  а также поле, отвечающее за тип ошибки.


  Основными полями, сигнализирующими об ошибках являются:

    - error         : "true" в случае возникновения какой-либо ошибки
        вообще
    - error_opcode  : "true" в случае неизвестного опкода
    - error_operand : "true" в случае, если один из операндов инструкции
        не является действительным для данной инструкции
    - error_length  : "true" в случае, если длина инструкции превышает
        допустимую (15 байт в X86)

  Кроме того, реализации для отдельных архитектур могут содержать
  поля для ошибок, специфические для данной архитектуры, например:
  "error_lock" в ssde_x86, которая сигнализирует о неверном использовании
  LOCK префикса.

3.3 Многопоточность

  SSDE не является потокобезопасным.

  Однако, многопоточный анализ для ветвлений кода может быть произведен
  используя потоки и отдельный объект дизассемблера, созданного специально
  для определенного ответвления.

4 Добавление поддержки новой архитектуры

  Для добавления поддержки новой архитектуры, нужно создать новый класс,
  который будет окончательным (final), иметь название "ssde_АРХИТЕКТУРА",
  происходить от "ssde" и использовать конструкторы ssde::ssde. Прототипы
  всех классов должны быть описаны в ssde.hpp. Пример:

    /* ssde.hpp */
      class ssde_arm final : public ssde
      {
      public:
        using ssde::ssde;

        void dec() override final; // Decode the instruction pointed by IP.

      private:
        void reset_fields();

      public:
        bool error_shift = false; // Bit shift used wrong.
      }

  Если Вы собираетесь участвовать в разработке проекта, стиль Вашего кода
  должен соответсвовать стилю остального кода в проекте. Допускается
  использование исключительно английского языка в названиях переменных,
  методов, классов, структур, енумераций, типов и прочих конструкций языка,
  а также комментариев.

5 Сообщение об ошибке и контакты

  В случае обнаружения какой-либо ошибки, перед тем как писать отчет,
  удостоверьтесь в том, что Вы используете самую последнюю версию SSDE,
  а также что ошибка находится именно в алгоритме SSDE, а не в Вашем коде.
  Отправить отчет можно на github по адресу http://github.com/notnanocat/ssde/issues
  Кроме отчета, очень рекомендуется приложить код, который воспроизводит
  ошибку алгоритма SSDE. Желательно, чтобы отчет был написан на английском
  языке. Отчет должен содержать информацию о том, в каких условиях
  возникает ошибка и название модуля и метода, в которых она возникает.